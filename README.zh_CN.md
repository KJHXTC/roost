# 微信公众号后台服务

## 说明

### 功能说明
本项目预置的服务功能 属于基础的服务管理功能,旨在提供一种助手式服务



com.kjhxtc.

## 许可协议
[Apache License Version 2.0](https://www.apache.org/licenses/LICENSE-2.0)

欢迎提出Issue(包括但不限于 缺陷 功能 疑问以及代码优化和其他意见)
欢迎 Pull Request
## 许可引用


## 结构说明


## RESTFul 国际化策略

HTTP 发起的RESTful 接口调用 
   如果是从浏览器发起的 (例如AJAX)常规有如下Header
   * Cookies
   * Referer
   * User-Agent
   * Accept-Language
      
   提取用户语言优先级 
   1. 如果 Cookie 中 存在 则从 优先执行 Cookie 的语言设定(用户最佳偏好)
   2. 如果 是可鉴别的用户 则 从
   3. 如果 QueryString 中`hl` [Google]存在且是有效的, 则执行 `hl` 设定
   4. 如果从 Accept-Language 提取
   5. 如果都没有, 则从服务端的默认中提取
   将用户语言优先级按照 提取结果排序
   
   国际化翻译,
   按照优先级的语言进行翻译,否则执行系统策略
   
  
  
  思考:
    基于模板的国际化可以减少复杂度,但对一些操作习惯 语言习惯等不同甚至相反的使用者来讲并不能被认可
    
    WEB服务应尽可能国际化(统一服务),但客户端(Desktop,APP)服务应尽可能的本地化(个性化服务)
    
    
## 动态的 WEB 服务
  一般来讲WEB(HTTP)服务需要如下的
  HTTP              Port 80   默认
  HTTP over TLS/SSL Port 443  默认
  主机 Host [DomainName:Port]
  
  先来回顾下
  而客户端在发起请求是 由于需要Socket 所以 会优先解析 
  Domain(FQDN)  ----DNS query ----> 最终 得到 IPAddress [IPv4 |IPv6]
  然后如果 自定义了端口 则使用端口 如果没有则使用默认端口
  在得到 IPAddress 和 Port 后 发起TCP连接
  连接成功后 
     如果是 HTTPS 由于多了一层 TLS/SSL 故 需要 进行安全认证 这里的参见 [](),完成后下一步
  然后
    发送 HTTP请求 {方法, 版本, 主机, Header, URI, 参数}
    
  好了,那么来看服务器如何解析查找对应的处理呢
  在被连接后(如果是TLS/SSL则是握手认证完成后)
  收到HTTP的请求
      提取 Host
      找到绑定的 Host 转发到 处理函数, 
      处理 根据 URI 规则 (路由规则) 找到 处理器
      
      处理器 根据 请求的 HTTP 方法 [GET | POST | DELETE ...} 执行对应的 函数
      函数 执行出 结果(页面/数据/异常 经上层进行数据渲染后 写入Socket)
      
     * 中间件
     * WEB服务器 静态资源 动态资源 nginx 反向代理
  另外了解下 **工具** 和 **框架** 的区别
  有兴趣的可以看下 tornado webServer 的 helloword 页面
  就需要这些 
    1. 注册 Host 
    2. 注册 路由  "/hello" -> helloWord.get()
    3. 实现 实现控制器 的方法 GET POST ...
    

  JAVA(java 派生的JVM系列语言) 因为有 JavaEE的规范标准化的框架因此 不少中间件都已实现和集成了基础的服务
  不需要你重复造轮子了(最简单的 tomcat 实现静态资源路由,动态的Http解析(http报文->java class服务))
  但用惯了python的(Flask Django  Tornado Web Web2 ...)的反而觉得用起来也是不舒服,有规则就有约束
  
  
## 全局思考
  
  多台服务器情况下如何处理
  
  哪些需要共享
  1. HTTP Session (认证信息 会话信息)
  2. 微信 accessToken (目前放在数据库,并本地缓存)
  3. 定时任务
  4. HTTP请求 不在单机存储 这次请求 在AServer 下次可能在BServer
  
  
##　安全设置

用户使用密码对TOKEN等信息(经计算的 TOKEN可能在网络中泄漏)进行 HMac算法计算的 mac值 作为认证票据
原理:　 
   在注册后, 用户方有`登录口令`和系统有`口令哈希`,因此二者存在预共享密钥

存储安全:
   用户方持有的是明文原文例如 `123456`,系统持有的是明文的哈希值 这里采用 `SHA-256` 作为哈希算法 
   同时系统后台使用系统密钥对用户的密码哈希值进行对称加密保护(同时算法系统只提供加密不提供解密功能来保证相对安全)
　   系统密钥 K AES e(内部唯一ID, 用户密码的哈希值 (不做任何加盐))

登录验证:
　 Ticket = HMac(HKey=HASH(Password), Message=Token)
　 用户密码本身不会在网络中传输 (这里采用HMac方式对请求参数签名)
　 需要包含时间戳(另外 客户端自身时间如果不正确,需要自行根据服务器的时间戳计算出当前的 UTC 时间)
  
问题:
  原来采用PBKDF2 为什么取消?
  PBKDF2需要 Salt和Iter, 这样,存储在数据库时需要 $SALT$ITER$VALUE
  但登录验证时,不利于使用HMac 需要提前告诉客户端 SALT和 ITER


实际上 用户注册登录的逻辑较为复杂
1. 通过微信等(SNS)一键登录, 此类账号没有密码, 但也仅限于通过微信等(SNS)对应登录
2. 通过 {用户名|手机号|邮箱} + 静态密码 的登录, 此类安全系数一般  
3. 在2的基础上 要求2次验证,包括但不限于手机验证码|邮箱动态码|用户已设定的OTP动态码等的双因素认证,但对于用户来讲普遍认为过于麻烦
4. 国内一些APP会采用 {手机号 + 动态码} 的方式进行登录,但个人认为如果不包含隐私信息的可以采用这种方式提供服务,类似于初次注册;
   一旦注册过了,且用户将自身隐私信息设置在其中之后, 采用这种方式就相当危险. 
   原因: 手机(号)丢失|更换|2G攻击导致信息劫持等,被当前**验证信息**持有者获取后,造成用户的隐私数据被非法获取, 因此要权衡
   
   如果用户设定个人隐私信息,那么在设定前一定要求设定保护/认证密码. 如果用户忘记密码才要求进行二次(动态认证)以及更多信息的识别与认证,
   但此类动态认证也仅限于**重置密码**这一功能,同时在重置后,向用户的其他关联信息发送 **密码被重置** 的消息提醒,并提供紧急账号锁定功能.
   参考 Google/微软等方式
5. 登录设计
   一般来说,为了有较好的用户体验,我们需要明确的指出用户的什么地方出错了,需要用户去修改纠正
   但是又考虑到一些奇葩的攻击/扫描方式,我们不得已给出用户一个含糊的错误 诸如"用户名或者密码错误" 其含义也可能是 "用户名不存在"
   但是在注册时,我们又需要保证用户注册的"用户名"是唯一的,所以会给出 "用户名已被占用"这类的提示

安全问题:   
   有这么一种情况,我是一名黑客从暗网搞了数亿华住会的那数亿用户的隐私信息(只说通用的)包括但不限于
   * 用户设定的密码
   * 用户的手机号
   * 用户的证件以及证件号
   * 用户的邮箱
   * 证件信息(类型 号码)
   * 其他信息 例如 早期的问答口令 你家的猪几岁?
   * 常用登录地点 
   那么他就可能来我的站点搞事情,例如 特别的由于用户喜欢互联网世界同一个密码,那么这就是一件很危险的事情,因为就有可能他伪装成那个用户来登陆
   流程很简单  -> 1. 输入手机号 -> 不存在? 放弃; 存在 ok
                2. 输入密码  -> 失败? 放弃;  
            等等 我还有邮箱
              1. 输入手机号 -> 不存在? 放弃; 先去其他网站; 存在 ok
              2. 输入密码  ->  失败? 放弃; 
            还不行, 这不是163邮箱吗,试试163密码是不是也这个 
              我去,可以用, 重置密码去
            ->  找回密码 -> 请输入邮箱地址 a038****@*3.com 的地址 ->  重置信息已发送到您的邮箱, 请按照邮件提示 进行密码重置
            
             -> 新邮件提示 -> 点击进行密码重置 -> 请设定您的 新密码, 确认密码 -> 密码已重置
             
          | -->  短信提示:  您的账号密码已重置 [XXXX] 
            -->  邮件提示:  您的账号密码已重置  
               如果用户较为警醒,一般可以即使发现 当然这种依赖用户警觉不确定性太大
             
   所以在认证时 对用户信息分安全等级 和 身份认证状态分安全等级是有必要的
   
   假设:
   
   与站点无关,或者无账号关联的 信息 等级 评级为 `0` 可被任意抓取, 无需保护
   注册.
   
       注册是从无到有的过程,也是最难区分的过程
       注册渠道多
         
          * SNS/openID 方式联合登录,严格范围并不一定注册过或者注册了, 可能用于本身并不属于站点,只是起到一个识别作用
             用户隐私数据也就随着使用等慢慢积累的 
                                    评级为 `1` 外部识别,外部提供认证安全性一般,只是起到用户识别
            但是有些网站的安全性可以认为相对较高,例如 微信 Google Facebook等
          * 邮箱 注册  历史悠久的注册方式
            安全性类似于 SNS/OPENID ,主要与提供者自身有关; 另外中国的用户普遍对email的安全重视程度较低,需要根据区域决定
            中国地区 建议 评级为 `1`-`3`,可以让用户自己调整,但不要超过 `4`
          * 手机号 便捷
             安全性较高(需要持有),一般来讲 较邮箱安全, 评级 `3`-`4` 但不要超过 `4`
          
          当认证评分低于某一操作所需的最低评分时,需要用户去设定, 一般的网站没有必要存储也不应该存储客户的身份证信息
          即 证件类型 身份证,证件ID XXXXXXXYYYYMMDDNNNN 
          5毛钱一条真的很廉价,对当今互联网安全影响很坏. 所以身份证这种证件性质的最好不要做为鉴别的加权分,还不如远古的静态密保问题方式.
          如果为了满足 工信部的实名认证需求,那么要求手机号绑定即可. 
          如果为了进行一些 用户信息代办(居然真的有这种业务), 请尽量对证件号加密存储. (家贼难防)
          
   登录.
   
         * 静态密码评分 `2`
         * SNS
            同注册
         * 邮箱-动态码
           同注册
         * 手机-短信验证码
           同注册
         * App扫码(但)
            与网站自身app研发能力等有关, 建议不要超过 `3` (APP自身防护 指纹识别防护等)
         * 硬件签名设备
            需要硬件(像银行动态令牌 U盾等)投入 用户体验较差, 但安全度高(硬件自身还需要密码保护) 建议 不超过 `6`
   
   密码重置.
      
      人总是善忘的,1分钟前刚设定的可能就忘了, 不少用户为了便于记忆,也是选择将密码存储在浏览器, 方便了自己 当然也方便了你身边的人🤨  
      如果是登录状态且已知密码,只是要更新密码,那么问题不大
      如果是忘记密码则需要进行一些检测 风险检测控制
      1. 登录地址是否是常用地址                      0-10
      2. 当前设备是否是常用设备                      0-10
      3. 近期 7Days 连续密码认证错误次数是否异常       0-10 
      4. 账号状态是否异常                           0-10
      5. 最后一次口令密码认证成功时间差                100 (1分钟内)/70 (5分钟内)/ 50 (10分钟内)/ 30 (30分钟内)/0
      如果 风险系数较小, 在方便用户的前提下, 通过高系数认证方式进行身份重置
      例如 用户设定了 邮箱 `2` 和手机号 `4`, 那么手机号的可信度就要高于邮箱, 系统就需要以高系数为准

   销号.
   
      存在伪造销户的可能,设定 销毁期
      1. 确认阶段 1D, 综合认证 密码 + 动态码 ,如果有高于 `4` 评分的单项认证 则需要通过该认证 
      2.1 禁用账号以及相关会话
      2.2 广播阶段, 向账号所有可推送源推送该通知消息 
      2.3 提供个人数据下载接口  1D-30D
      3. 移除数据 30D-90D
            
安全类型  安全用途       初始化设定值     移除值(需验证旧值)  移除/直接重写(无效验证)    

密码      注册           3              3               >3
密码      初次设定        2              3               >3
密码      认证         成功 {1-4}

手机号    注册            4              3             >4
手机号    后期绑定         2            3               >3 
手机号    认证          成功 {3-4}

邮箱      注册            3           3              >3
邮箱      后期绑定         2           2              >2
邮箱      认证          成功 {2-4}

2FA       绑定          4            4               >4 
2FA备份码  单次有效
          静态存储       3            3              无法重写 后台系统自动产生
          认证          成功 3

SNS        注册        2            取消绑定:3         3
SNS        后期绑定    {1-2}         3                >3          
SNS        认证       成功 1


处于认证后状态的会话值 为 1,否则为0

整体安全评值为:
    登录状态{0-1}  + 认证方式{0|对应值} + 安全环境评分{0-2}


隐私安全模型与会话评分关联

  完全公开型(只读,不存在写)
       0  
       
  内部公开型(只读,不存在写)
       1
  
  隐私公开型(读取更低基本数据和写入同级别数据)
       2
  
  私有型(允许读取个人隐私数据,允许写入同级别数据)     
       3
  
  鉴别型(允许验证通过后修改原数据, 允许修改低级别数据) 含检测加权分
       4     
